// Dynamic Analysis methods:
// State (time) Vector=[time,x,y,r,  vx,vy,vr,  ax,ay,ar]; 
//                     0   1 2 3    4  5  6   7  8   9
KT=0; // time
KX=1; // x position of center of mass
KY=2; // y position of center of mass
KR=3; // rotation (radians)
KVX=4; // x velocity
KVY=5; // y velocity
KVR=6; // rotational velocity
KAX=7; // x acceleration
KAY=8; // y acceleration
KAR=9; // rotational acceleration
//
G = 980.665;  // cm/sec^2
END_TIME = 1.0;  // seconds
DT = 0.02; // delta time in seconds

INIT_ANG = 30; // DEG
INIT_POS = XY_from_A(INIT_ANG);
FINAL_POS = [PI*WHEEL_DIA-INIT_POS[0],INIT_POS[1],0];
translate(FINAL_POS) color("blue") cube([0.5,10,1],center=true);
echo(FINIAL_POS=FINAL_POS);

// Vector=[time,x,y,r,  vx,vy,vr,  ax,ay,ar]; 
KIN_0=    [0,INIT_POS[0],INIT_POS[1],INIT_ANG*PI/180, 0,0,0, 0,-G,INIT_POS[2]]; // initial kinematics

function SUM_M(radius,mass,CMy,Izz,torque) =
    // NOT USED
    // returns change in rotational acceleration of wheel
    (mass*G*CMy*sin(radius) + torque)/Izz;
    
function XY_from_A(Angle) = 
    // Cog Whobble Wheel function, returns X,Y,Angle Accel give angle
    // Angle is in Degrees (unlike the other times!)
    // Third value is Angular acceleration
    [(Angle*PI/180)*WHEEL_DIA/2 + sin(Angle)*OBJCMy,cos(Angle)*OBJCMy, (OBJM*G*sin(Angle)*OBJCMy)/OBJI];
    
// RECURSIVE TIME STEP FUNCTION, GENERATES ARRAY OF DYNAMIC POSITIONS
function time_stepper(DELTA_T,END_T,PRIOR,time=0) = 
    echo(str(",",time,",",PRIOR[KX],",",PRIOR[KY],",",PRIOR[KR], ",", PRIOR[KVX],",",PRIOR[KVY],",",PRIOR[KVR],",", PRIOR[KAX],",", PRIOR[KAY],",",PRIOR[KAR],","))
    // COMPUTE NEXT TIME:
    let (Acentrip = pow(PRIOR[KVR],2)/OBJCMy) // Centripital Acceleration = v^2/R
    let (AX = Acentrip*sin(PRIOR[KR]*180/PI))  // only Centripital Accel for whob wheel?
    let (AY = -G + Acentrip*cos(PRIOR[KR]*180/PI)) // SUM FORCES Y (Gravity in the -Y direction plus centripital acceleration)
    let (AR = (OBJM*G*sin(PRIOR[KR]*180/PI)*OBJCMy + OBJM*AX*cos(PRIOR[KR]*180/PI)/2)/OBJI) // SUM MOMENTS
    let (VX = (PRIOR[KVX] + AX*DELTA_T)) // integrate accel to get velo
    let (VY = (PRIOR[KVY] + AY*DELTA_T))
    let (VR = (PRIOR[KVR] + AR*DELTA_T)) 
    let (R = PRIOR[KR] + VR*DELTA_T)  // R = ROTATION IN RADIANS
    let (X = R*WHEEL_DIA/2 + sin(R*180/PI)*OBJCMy) // COG WHEEL
    //let (X = PRIOR[KX] + PRIOR[KVX]*DELTA_T)
    let (Y = cos(R*180/PI)*OBJCMy)   // COG WHEEL
    //let (Y = PRIOR[KY] + PRIOR[KVY]*DELTA_T)
    let (NEXT_STEP = [time+DELTA_T,X,Y,R,VX,VY,VR,AX,AY,AR])
    (time <= END_T) ? 
        concat([PRIOR],time_stepper(DELTA_T=DELTA_T,END_T=END_T, PRIOR=NEXT_STEP,time=time+DELTA_T)) :
        [PRIOR] ;

function echo_header() =
    // This function writes header line before data lines for spreadsheet
    echo(str(",time,X,Y,rot,X velo,Y velo,rot velo,X accel,Yaccel,rot accel,"));
dummy = echo_header(); // for spreadsheet

SIM1=time_stepper(DELTA_T=DT,END_T=END_TIME,PRIOR=KIN_0);
//echo(SIM1=SIM1);
drawSIM(SIM=SIM1,DELTA_T=DT,END_T=END_TIME);

// Recursive module to draw the center of mass of a simulation
module drawSIM(SIM,DELTA_T,END_T,PRIOR,time=0,i=0) {
    if (time <= END_T) {
        // draw center of mass indicator
        color("green") 
            translate([SIM[i][KX],SIM[i][KY],0])
                rotate([0,0,(-SIM[i][KR])*180/PI]) {
                    cylinder(h=1,r=0.5,$fn=FACETS);
                    cube([2,0.2,1],center=true);
                };
        // recursive call to draw next time step
        drawSIM(SIM=SIM1,DELTA_T=DT,END_T=END_TIME,time=time+DELTA_T,i=i+1);
    };
};